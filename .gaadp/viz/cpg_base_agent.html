<!DOCTYPE html>
<html>
<head>
    <title>GAADP Knowledge Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        #graph { width: 100vw; height: 100vh; }
        .node { cursor: pointer; }
        .node text { font-size: 10px; }
        .link { stroke-opacity: 0.6; }
        .tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 4px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="graph"></div>
    <script>
        const data = {"nodes": [{"id": "code_8986981870346077726", "type": "CODE", "status": "PENDING", "content_preview": "\"\"\"\nBASE AGENT (Hardened with MCP & RBAC)\nIntegrates Runtime Signing, File Locks, LLM Gateway, and T", "color": "#96CEB4", "metadata": {"file_path": "agents/base_agent.py", "language": "python", "imports": ["json", "logging", "yaml", "os", "time", "abc", "typing", "cryptography.hazmat.primitives.asymmetric", "cryptography.hazmat.primitives", "infrastructure.llm_gateway", "core.ontology", "infrastructure.mcp_hub", "re"], "classes": ["BaseAgent"], "functions": ["__init__", "_save_keys", "acquire_lock", "release_lock", "sign_content", "_hydrate_prompt", "_parse_json_response", "get_tools_schema", "check_tool_permission", "execute_tool_calls", "process"]}}, {"id": "phantom_import_json", "type": "CODE", "status": "COMPLETE", "content_preview": "json", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_logging", "type": "CODE", "status": "COMPLETE", "content_preview": "logging", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_yaml", "type": "CODE", "status": "COMPLETE", "content_preview": "yaml", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_os", "type": "CODE", "status": "COMPLETE", "content_preview": "os", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_time", "type": "CODE", "status": "COMPLETE", "content_preview": "time", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_abc", "type": "CODE", "status": "COMPLETE", "content_preview": "abc", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_typing", "type": "CODE", "status": "COMPLETE", "content_preview": "typing", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_cryptography.hazmat.primitives.asymmetric", "type": "CODE", "status": "COMPLETE", "content_preview": "cryptography.hazmat.primitives.asymmetric", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_cryptography.hazmat.primitives", "type": "CODE", "status": "COMPLETE", "content_preview": "cryptography.hazmat.primitives", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_infrastructure.llm_gateway", "type": "CODE", "status": "COMPLETE", "content_preview": "infrastructure.llm_gateway", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_core.ontology", "type": "CODE", "status": "COMPLETE", "content_preview": "core.ontology", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_infrastructure.mcp_hub", "type": "CODE", "status": "COMPLETE", "content_preview": "infrastructure.mcp_hub", "color": "#96CEB4", "metadata": {}}, {"id": "phantom_import_re", "type": "CODE", "status": "COMPLETE", "content_preview": "re", "color": "#96CEB4", "metadata": {}}, {"id": "class_BaseAgent", "type": "CLASS", "status": "COMPLETE", "content_preview": "class BaseAgent(ABC):\n    def __init__(\n        self,\n        agent_id: str,\n        role: AgentRole", "color": "#9B59B6", "metadata": {"name": "BaseAgent", "lineno": 24, "col_offset": 0, "bases": ["ABC"], "content": "class BaseAgent(ABC):\n    def __init__(\n        self,\n        agent_id: str,\n        role: AgentRole,\n        graph_db,\n        mcp_hub: Optional[\"MCPHub\"] = None\n    ):\n        self.agent_id = agent_id\n        self.role = role\n        self.graph_db = graph_db\n        self.mcp_hub = mcp_hub\n        self.gateway = LLMGateway()\n        self.logger = logging.getLogger(f\"Agent.{role}.{agent_id}\")\n        self._private_key = ed25519.Ed25519PrivateKey.generate()\n        self._public_key = self._private_key.public_key()\n        self._save_keys()\n\n        with open(\".blueprint/prompt_templates.yaml\", \"r\") as f:\n            self.templates = yaml.safe_load(f)\n        with open(\".blueprint/prime_directives.md\", \"r\") as f:\n            self.directives = f.read()\n\n        # Load topology for RBAC\n        try:\n            with open(\".blueprint/topology_config.yaml\", \"r\") as f:\n                self.topology = yaml.safe_load(f)\n        except FileNotFoundError:\n            self.topology = {\"tool_permissions\": {}}\n\n        # Cache allowed tools for fast lookup\n        self.allowed_tools = (\n            self.topology\n            .get(\"tool_permissions\", {})\n            .get(role.value, {})\n            .get(\"allowed_tools\", [])\n        )\n\n    def _save_keys(self):\n        key_dir = \".gaadp/keys\"\n        os.makedirs(key_dir, exist_ok=True)\n        pub_key_path = f\"{key_dir}/{self.agent_id}.pub\"\n        pem = self._public_key.public_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PublicFormat.SubjectPublicKeyInfo\n        )\n        with open(pub_key_path, \"wb\") as f:\n            f.write(pem)\n\n    def acquire_lock(self, node_id: str, timeout: int = 10) -> bool:\n        lock_dir = \".gaadp/locks\"\n        os.makedirs(lock_dir, exist_ok=True)\n        lock_file = f\"{lock_dir}/{node_id}.lock\"\n        start_time = time.time()\n        while time.time() - start_time < timeout:\n            try:\n                with open(lock_file, \"x\") as f:\n                    f.write(self.agent_id)\n                return True\n            except FileExistsError:\n                if os.path.getmtime(lock_file) < time.time() - 30:\n                    os.remove(lock_file)\n                    continue\n                time.sleep(0.1)\n        return False\n\n    def release_lock(self, node_id: str):\n        lock_file = f\".gaadp/locks/{node_id}.lock\"\n        if os.path.exists(lock_file):\n            os.remove(lock_file)\n\n    def sign_content(self, content: Any, previous_hash: str = \"GENESIS\") -> str:\n        \"\"\"\n        Cryptographically signs data linked to history.\n        Creates a Merkle-like chain of custody.\n        \"\"\"\n        payload = {\n            \"content\": content,\n            \"prev_hash\": previous_hash,\n            \"agent_id\": self.agent_id,\n            \"timestamp\": time.time()\n        }\n        data_bytes = json.dumps(payload, sort_keys=True).encode('utf-8')\n        signature = self._private_key.sign(data_bytes).hex()\n        return signature\n\n    def _hydrate_prompt(self, template_id: str, vars: Dict) -> str:\n        template = self.templates.get(template_id, {}).get('instruction', \"\")\n        vars['prime_directives_text'] = self.directives\n        vars['agent_role'] = self.role.value\n        vars['agent_id'] = self.agent_id\n        return template.format(**vars)\n\n    def _parse_json_response(self, text: str) -> Dict:\n        \"\"\"\n        Parse LLM response, handling JSON, Markdown blocks, and mixed content.\n\n        Strategies:\n        1. Direct JSON parse\n        2. Extract from ```json ... ``` blocks\n        3. Find first outer brace { ... }\n        4. Raise ValueError with debug output\n\n        Args:\n            text: Raw LLM response\n\n        Returns:\n            Parsed dict\n\n        Raises:\n            ValueError: If no valid JSON can be extracted\n        \"\"\"\n        import re\n\n        if not text or not text.strip():\n            raise ValueError(\"Empty response from LLM\")\n\n        text = text.strip()\n\n        # 1. Try direct parsing\n        try:\n            return json.loads(text)\n        except json.JSONDecodeError:\n            pass\n\n        # 2. Try extracting from ```json ... ``` blocks\n        match = re.search(r\"```(?:json)?\\s*(.*?)```\", text, re.DOTALL)\n        if match:\n            try:\n                return json.loads(match.group(1))\n            except json.JSONDecodeError:\n                pass\n\n        # 3. Try finding the first outer brace { ... }\n        match = re.search(r\"(\\{.*\\})\", text, re.DOTALL)\n        if match:\n            try:\n                return json.loads(match.group(1))\n            except json.JSONDecodeError:\n                pass\n\n        # 4. Debug: Print what failed and return a sensible default\n        print(f\"\u274c JSON PARSE FAILED. Raw Output:\\n{text[:500]}...\\n\")\n        self.logger.warning(\"LLM returned non-JSON response, wrapping as content\")\n        return {\n            \"content\": text,\n            \"verdict\": \"FAIL\",\n            \"critique\": \"LLM failed to produce valid JSON output - response was conversational text\",\n            \"parse_error\": True\n        }\n\n    def get_tools_schema(self) -> List[Dict]:\n        \"\"\"Get filtered tool schemas for this agent's role.\"\"\"\n        if self.mcp_hub:\n            return self.mcp_hub.get_tools_for_role(self.role.value)\n        return []\n\n    def check_tool_permission(self, tool_name: str) -> bool:\n        \"\"\"Check if this agent can use a specific tool.\"\"\"\n        return tool_name in self.allowed_tools\n\n    async def execute_tool_calls(self, response: Dict) -> str:\n        \"\"\"\n        Execute tool calls from LLM response with permission checking.\n\n        Args:\n            response: Parsed LLM response containing tool_calls\n\n        Returns:\n            Concatenated results from all tool executions\n\n        Supports multiple tool call formats:\n            - OpenAI/Anthropic API format: {\"function\": {\"name\": \"...\", \"arguments\": \"...\"}}\n            - Simple format: {\"name\": \"...\", \"input\": {...}}\n        \"\"\"\n        if not self.mcp_hub:\n            return \"No MCP Hub configured\"\n\n        tool_calls = response.get('tool_calls', [])\n        results_log = []\n\n        for call in tool_calls:\n            # Support both API format and simple format\n            if 'function' in call:\n                # OpenAI/Anthropic API format\n                func_name = call['function']['name']\n                raw_args = call['function'].get('arguments', '{}')\n            else:\n                # Simple format (e.g., from ManualProvider)\n                func_name = call.get('name', 'unknown')\n                raw_args = call.get('input', {})\n\n            # Handle arguments: can be string (needs parsing) or dict (use directly)\n            if isinstance(raw_args, str):\n                try:\n                    args = json.loads(raw_args)\n                except json.JSONDecodeError:\n                    results_log.append(f\"Tool '{func_name}' Failed: Invalid JSON arguments: {raw_args}\")\n                    continue\n            elif isinstance(raw_args, dict):\n                args = raw_args\n            else:\n                args = {}\n\n            # SECURITY CHECK\n            if not self.check_tool_permission(func_name):\n                denial_msg = (\n                    f\"\u26d4 SECURITY ALERT: Agent '{self.agent_id}' ({self.role.value}) \"\n                    f\"attempted to use forbidden tool '{func_name}'\"\n                )\n                self.logger.warning(denial_msg)\n                results_log.append(denial_msg)\n                continue\n\n            try:\n                self.logger.info(f\"\ud83d\udee0\ufe0f Executing Tool: {func_name}\")\n                result = await self.mcp_hub.execute_tool(\n                    func_name, args, role_name=self.role.value\n                )\n                results_log.append(f\"Tool '{func_name}' Output: {str(result)}\")\n            except PermissionError as e:\n                results_log.append(f\"\u26d4 Permission Denied: {str(e)}\")\n            except Exception as e:\n                results_log.append(f\"Tool '{func_name}' Failed: {str(e)}\")\n\n        return \"\\n\".join(results_log)\n\n    @abstractmethod\n    async def process(self, context: Dict) -> Dict:\n        pass"}}, {"id": "function___init__", "type": "FUNCTION", "status": "COMPLETE", "content_preview": "def __init__(\n        self,\n        agent_id: str,\n        role: AgentRole,\n        graph_db,\n      ", "color": "#3498DB", "metadata": {"name": "__init__", "lineno": 25, "col_offset": 4, "is_async": false, "args": ["self", "agent_id", "role", "graph_db", "mcp_hub"], "content": "def __init__(\n        self,\n        agent_id: str,\n        role: AgentRole,\n        graph_db,\n        mcp_hub: Optional[\"MCPHub\"] = None\n    ):\n        self.agent_id = agent_id\n        self.role = role\n        self.graph_db = graph_db\n        self.mcp_hub = mcp_hub\n        self.gateway = LLMGateway()\n        self.logger = logging.getLogger(f\"Agent.{role}.{agent_id}\")\n        self._private_key = ed25519.Ed25519PrivateKey.generate()\n        self._public_key = self._private_key.public_key()\n        self._save_keys()\n\n        with open(\".blueprint/prompt_templates.yaml\", \"r\") as f:\n            self.templates = yaml.safe_load(f)\n        with open(\".blueprint/prime_directives.md\", \"r\") as f:\n            self.directives = f.read()\n\n        # Load topology for RBAC\n        try:\n            with open(\".blueprint/topology_config.yaml\", \"r\") as f:\n                self.topology = yaml.safe_load(f)\n        except FileNotFoundError:\n            self.topology = {\"tool_permissions\": {}}\n\n        # Cache allowed tools for fast lookup\n        self.allowed_tools = (\n            self.topology\n            .get(\"tool_permissions\", {})\n            .get(role.value, {})\n            .get(\"allowed_tools\", [])\n        )"}}, {"id": "function__save_keys", "type": "FUNCTION", "status": "COMPLETE", "content_preview": "def _save_keys(self):\n        key_dir = \".gaadp/keys\"\n        os.makedirs(key_dir, exist_ok=True)\n  ", "color": "#3498DB", "metadata": {"name": "_save_keys", "lineno": 62, "col_offset": 4, "is_async": false, "args": ["self"], "content": "def _save_keys(self):\n        key_dir = \".gaadp/keys\"\n        os.makedirs(key_dir, exist_ok=True)\n        pub_key_path = f\"{key_dir}/{self.agent_id}.pub\"\n        pem = self._public_key.public_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PublicFormat.SubjectPublicKeyInfo\n        )\n        with open(pub_key_path, \"wb\") as f:\n            f.write(pem)"}}, {"id": "function_acquire_lock", "type": "FUNCTION", "status": "COMPLETE", "content_preview": "def acquire_lock(self, node_id: str, timeout: int = 10) -> bool:\n        lock_dir = \".gaadp/locks\"\n ", "color": "#3498DB", "metadata": {"name": "acquire_lock", "lineno": 73, "col_offset": 4, "is_async": false, "args": ["self", "node_id", "timeout"], "content": "def acquire_lock(self, node_id: str, timeout: int = 10) -> bool:\n        lock_dir = \".gaadp/locks\"\n        os.makedirs(lock_dir, exist_ok=True)\n        lock_file = f\"{lock_dir}/{node_id}.lock\"\n        start_time = time.time()\n        while time.time() - start_time < timeout:\n            try:\n                with open(lock_file, \"x\") as f:\n                    f.write(self.agent_id)\n                return True\n            except FileExistsError:\n                if os.path.getmtime(lock_file) < time.time() - 30:\n                    os.remove(lock_file)\n                    continue\n                time.sleep(0.1)\n        return False"}}, {"id": "function_release_lock", "type": "FUNCTION", "status": "COMPLETE", "content_preview": "def release_lock(self, node_id: str):\n        lock_file = f\".gaadp/locks/{node_id}.lock\"\n        if ", "color": "#3498DB", "metadata": {"name": "release_lock", "lineno": 90, "col_offset": 4, "is_async": false, "args": ["self", "node_id"], "content": "def release_lock(self, node_id: str):\n        lock_file = f\".gaadp/locks/{node_id}.lock\"\n        if os.path.exists(lock_file):\n            os.remove(lock_file)"}}, {"id": "function_sign_content", "type": "FUNCTION", "status": "COMPLETE", "content_preview": "def sign_content(self, content: Any, previous_hash: str = \"GENESIS\") -> str:\n        \"\"\"\n        Cry", "color": "#3498DB", "metadata": {"name": "sign_content", "lineno": 95, "col_offset": 4, "is_async": false, "args": ["self", "content", "previous_hash"], "content": "def sign_content(self, content: Any, previous_hash: str = \"GENESIS\") -> str:\n        \"\"\"\n        Cryptographically signs data linked to history.\n        Creates a Merkle-like chain of custody.\n        \"\"\"\n        payload = {\n            \"content\": content,\n            \"prev_hash\": previous_hash,\n            \"agent_id\": self.agent_id,\n            \"timestamp\": time.time()\n        }\n        data_bytes = json.dumps(payload, sort_keys=True).encode('utf-8')\n        signature = self._private_key.sign(data_bytes).hex()\n        return signature"}}, {"id": "function__hydrate_prompt", "type": "FUNCTION", "status": "COMPLETE", "content_preview": "def _hydrate_prompt(self, template_id: str, vars: Dict) -> str:\n        template = self.templates.ge", "color": "#3498DB", "metadata": {"name": "_hydrate_prompt", "lineno": 110, "col_offset": 4, "is_async": false, "args": ["self", "template_id", "vars"], "content": "def _hydrate_prompt(self, template_id: str, vars: Dict) -> str:\n        template = self.templates.get(template_id, {}).get('instruction', \"\")\n        vars['prime_directives_text'] = self.directives\n        vars['agent_role'] = self.role.value\n        vars['agent_id'] = self.agent_id\n        return template.format(**vars)"}}, {"id": "function__parse_json_response", "type": "FUNCTION", "status": "COMPLETE", "content_preview": "def _parse_json_response(self, text: str) -> Dict:\n        \"\"\"\n        Parse LLM response, handling ", "color": "#3498DB", "metadata": {"name": "_parse_json_response", "lineno": 117, "col_offset": 4, "is_async": false, "args": ["self", "text"], "content": "def _parse_json_response(self, text: str) -> Dict:\n        \"\"\"\n        Parse LLM response, handling JSON, Markdown blocks, and mixed content.\n\n        Strategies:\n        1. Direct JSON parse\n        2. Extract from ```json ... ``` blocks\n        3. Find first outer brace { ... }\n        4. Raise ValueError with debug output\n\n        Args:\n            text: Raw LLM response\n\n        Returns:\n            Parsed dict\n\n        Raises:\n            ValueError: If no valid JSON can be extracted\n        \"\"\"\n        import re\n\n        if not text or not text.strip():\n            raise ValueError(\"Empty response from LLM\")\n\n        text = text.strip()\n\n        # 1. Try direct parsing\n        try:\n            return json.loads(text)\n        except json.JSONDecodeError:\n            pass\n\n        # 2. Try extracting from ```json ... ``` blocks\n        match = re.search(r\"```(?:json)?\\s*(.*?)```\", text, re.DOTALL)\n        if match:\n            try:\n                return json.loads(match.group(1))\n            except json.JSONDecodeError:\n                pass\n\n        # 3. Try finding the first outer brace { ... }\n        match = re.search(r\"(\\{.*\\})\", text, re.DOTALL)\n        if match:\n            try:\n                return json.loads(match.group(1))\n            except json.JSONDecodeError:\n                pass\n\n        # 4. Debug: Print what failed and return a sensible default\n        print(f\"\u274c JSON PARSE FAILED. Raw Output:\\n{text[:500]}...\\n\")\n        self.logger.warning(\"LLM returned non-JSON response, wrapping as content\")\n        return {\n            \"content\": text,\n            \"verdict\": \"FAIL\",\n            \"critique\": \"LLM failed to produce valid JSON output - response was conversational text\",\n            \"parse_error\": True\n        }"}}, {"id": "function_get_tools_schema", "type": "FUNCTION", "status": "COMPLETE", "content_preview": "def get_tools_schema(self) -> List[Dict]:\n        \"\"\"Get filtered tool schemas for this agent's role", "color": "#3498DB", "metadata": {"name": "get_tools_schema", "lineno": 175, "col_offset": 4, "is_async": false, "args": ["self"], "content": "def get_tools_schema(self) -> List[Dict]:\n        \"\"\"Get filtered tool schemas for this agent's role.\"\"\"\n        if self.mcp_hub:\n            return self.mcp_hub.get_tools_for_role(self.role.value)\n        return []"}}, {"id": "function_check_tool_permission", "type": "FUNCTION", "status": "COMPLETE", "content_preview": "def check_tool_permission(self, tool_name: str) -> bool:\n        \"\"\"Check if this agent can use a sp", "color": "#3498DB", "metadata": {"name": "check_tool_permission", "lineno": 181, "col_offset": 4, "is_async": false, "args": ["self", "tool_name"], "content": "def check_tool_permission(self, tool_name: str) -> bool:\n        \"\"\"Check if this agent can use a specific tool.\"\"\"\n        return tool_name in self.allowed_tools"}}, {"id": "function_execute_tool_calls", "type": "FUNCTION", "status": "COMPLETE", "content_preview": "async def execute_tool_calls(self, response: Dict) -> str:\n        \"\"\"\n        Execute tool calls fr", "color": "#3498DB", "metadata": {"name": "execute_tool_calls", "lineno": 185, "col_offset": 4, "is_async": true, "args": ["self", "response"], "content": "async def execute_tool_calls(self, response: Dict) -> str:\n        \"\"\"\n        Execute tool calls from LLM response with permission checking.\n\n        Args:\n            response: Parsed LLM response containing tool_calls\n\n        Returns:\n            Concatenated results from all tool executions\n\n        Supports multiple tool call formats:\n            - OpenAI/Anthropic API format: {\"function\": {\"name\": \"...\", \"arguments\": \"...\"}}\n            - Simple format: {\"name\": \"...\", \"input\": {...}}\n        \"\"\"\n        if not self.mcp_hub:\n            return \"No MCP Hub configured\"\n\n        tool_calls = response.get('tool_calls', [])\n        results_log = []\n\n        for call in tool_calls:\n            # Support both API format and simple format\n            if 'function' in call:\n                # OpenAI/Anthropic API format\n                func_name = call['function']['name']\n                raw_args = call['function'].get('arguments', '{}')\n            else:\n                # Simple format (e.g., from ManualProvider)\n                func_name = call.get('name', 'unknown')\n                raw_args = call.get('input', {})\n\n            # Handle arguments: can be string (needs parsing) or dict (use directly)\n            if isinstance(raw_args, str):\n                try:\n                    args = json.loads(raw_args)\n                except json.JSONDecodeError:\n                    results_log.append(f\"Tool '{func_name}' Failed: Invalid JSON arguments: {raw_args}\")\n                    continue\n            elif isinstance(raw_args, dict):\n                args = raw_args\n            else:\n                args = {}\n\n            # SECURITY CHECK\n            if not self.check_tool_permission(func_name):\n                denial_msg = (\n                    f\"\u26d4 SECURITY ALERT: Agent '{self.agent_id}' ({self.role.value}) \"\n                    f\"attempted to use forbidden tool '{func_name}'\"\n                )\n                self.logger.warning(denial_msg)\n                results_log.append(denial_msg)\n                continue\n\n            try:\n                self.logger.info(f\"\ud83d\udee0\ufe0f Executing Tool: {func_name}\")\n                result = await self.mcp_hub.execute_tool(\n                    func_name, args, role_name=self.role.value\n                )\n                results_log.append(f\"Tool '{func_name}' Output: {str(result)}\")\n            except PermissionError as e:\n                results_log.append(f\"\u26d4 Permission Denied: {str(e)}\")\n            except Exception as e:\n                results_log.append(f\"Tool '{func_name}' Failed: {str(e)}\")\n\n        return \"\\n\".join(results_log)"}}, {"id": "function_process", "type": "FUNCTION", "status": "COMPLETE", "content_preview": "async def process(self, context: Dict) -> Dict:\n        pass", "color": "#3498DB", "metadata": {"name": "process", "lineno": 252, "col_offset": 4, "is_async": true, "args": ["self", "context"], "content": "async def process(self, context: Dict) -> Dict:\n        pass"}}, {"id": "call_LLMGateway", "type": "CALL", "status": "COMPLETE", "content_preview": "LLMGateway", "color": "#E67E22", "metadata": {"lineno": 36, "col_offset": 23, "args_count": 0}}, {"id": "call_getLogger", "type": "CALL", "status": "COMPLETE", "content_preview": "getLogger", "color": "#E67E22", "metadata": {"lineno": 37, "col_offset": 22, "args_count": 1}}, {"id": "call_generate", "type": "CALL", "status": "COMPLETE", "content_preview": "generate", "color": "#E67E22", "metadata": {"lineno": 38, "col_offset": 28, "args_count": 0}}, {"id": "call_public_key", "type": "CALL", "status": "COMPLETE", "content_preview": "public_key", "color": "#E67E22", "metadata": {"lineno": 39, "col_offset": 27, "args_count": 0}}, {"id": "call__save_keys", "type": "CALL", "status": "COMPLETE", "content_preview": "_save_keys", "color": "#E67E22", "metadata": {"lineno": 40, "col_offset": 8, "args_count": 0}}, {"id": "call_get", "type": "CALL", "status": "COMPLETE", "content_preview": "get", "color": "#E67E22", "metadata": {"lineno": 56, "col_offset": 12, "args_count": 2}}, {"id": "call_makedirs", "type": "CALL", "status": "COMPLETE", "content_preview": "makedirs", "color": "#E67E22", "metadata": {"lineno": 75, "col_offset": 8, "args_count": 1}}, {"id": "call_public_bytes", "type": "CALL", "status": "COMPLETE", "content_preview": "public_bytes", "color": "#E67E22", "metadata": {"lineno": 66, "col_offset": 14, "args_count": 0}}, {"id": "call_time", "type": "CALL", "status": "COMPLETE", "content_preview": "time", "color": "#E67E22", "metadata": {"lineno": 84, "col_offset": 49, "args_count": 0}}, {"id": "call_exists", "type": "CALL", "status": "COMPLETE", "content_preview": "exists", "color": "#E67E22", "metadata": {"lineno": 92, "col_offset": 11, "args_count": 1}}, {"id": "call_encode", "type": "CALL", "status": "COMPLETE", "content_preview": "encode", "color": "#E67E22", "metadata": {"lineno": 106, "col_offset": 21, "args_count": 1}}, {"id": "call_hex", "type": "CALL", "status": "COMPLETE", "content_preview": "hex", "color": "#E67E22", "metadata": {"lineno": 107, "col_offset": 20, "args_count": 0}}, {"id": "call_format", "type": "CALL", "status": "COMPLETE", "content_preview": "format", "color": "#E67E22", "metadata": {"lineno": 115, "col_offset": 15, "args_count": 0}}, {"id": "call_strip", "type": "CALL", "status": "COMPLETE", "content_preview": "strip", "color": "#E67E22", "metadata": {"lineno": 138, "col_offset": 27, "args_count": 0}}, {"id": "call_search", "type": "CALL", "status": "COMPLETE", "content_preview": "search", "color": "#E67E22", "metadata": {"lineno": 158, "col_offset": 16, "args_count": 3}}, {"id": "call_print", "type": "CALL", "status": "COMPLETE", "content_preview": "print", "color": "#E67E22", "metadata": {"lineno": 166, "col_offset": 8, "args_count": 1}}, {"id": "call_warning", "type": "CALL", "status": "COMPLETE", "content_preview": "warning", "color": "#E67E22", "metadata": {"lineno": 234, "col_offset": 16, "args_count": 1}}, {"id": "call_join", "type": "CALL", "status": "COMPLETE", "content_preview": "join", "color": "#E67E22", "metadata": {"lineno": 249, "col_offset": 15, "args_count": 1}}, {"id": "call_open", "type": "CALL", "status": "COMPLETE", "content_preview": "open", "color": "#E67E22", "metadata": {"lineno": 80, "col_offset": 21, "args_count": 2}}, {"id": "call_safe_load", "type": "CALL", "status": "COMPLETE", "content_preview": "safe_load", "color": "#E67E22", "metadata": {"lineno": 50, "col_offset": 32, "args_count": 1}}, {"id": "call_read", "type": "CALL", "status": "COMPLETE", "content_preview": "read", "color": "#E67E22", "metadata": {"lineno": 45, "col_offset": 30, "args_count": 0}}, {"id": "call_write", "type": "CALL", "status": "COMPLETE", "content_preview": "write", "color": "#E67E22", "metadata": {"lineno": 81, "col_offset": 20, "args_count": 1}}, {"id": "call_remove", "type": "CALL", "status": "COMPLETE", "content_preview": "remove", "color": "#E67E22", "metadata": {"lineno": 85, "col_offset": 20, "args_count": 1}}, {"id": "call_ValueError", "type": "CALL", "status": "COMPLETE", "content_preview": "ValueError", "color": "#E67E22", "metadata": {"lineno": 139, "col_offset": 18, "args_count": 1}}, {"id": "call_loads", "type": "CALL", "status": "COMPLETE", "content_preview": "loads", "color": "#E67E22", "metadata": {"lineno": 219, "col_offset": 27, "args_count": 1}}, {"id": "call_get_tools_for_role", "type": "CALL", "status": "COMPLETE", "content_preview": "get_tools_for_role", "color": "#E67E22", "metadata": {"lineno": 178, "col_offset": 19, "args_count": 1}}, {"id": "call_isinstance", "type": "CALL", "status": "COMPLETE", "content_preview": "isinstance", "color": "#E67E22", "metadata": {"lineno": 223, "col_offset": 17, "args_count": 2}}, {"id": "call_dumps", "type": "CALL", "status": "COMPLETE", "content_preview": "dumps", "color": "#E67E22", "metadata": {"lineno": 106, "col_offset": 21, "args_count": 1}}, {"id": "call_sign", "type": "CALL", "status": "COMPLETE", "content_preview": "sign", "color": "#E67E22", "metadata": {"lineno": 107, "col_offset": 20, "args_count": 1}}, {"id": "call_check_tool_permission", "type": "CALL", "status": "COMPLETE", "content_preview": "check_tool_permission", "color": "#E67E22", "metadata": {"lineno": 229, "col_offset": 19, "args_count": 1}}, {"id": "call_append", "type": "CALL", "status": "COMPLETE", "content_preview": "append", "color": "#E67E22", "metadata": {"lineno": 221, "col_offset": 20, "args_count": 1}}, {"id": "call_info", "type": "CALL", "status": "COMPLETE", "content_preview": "info", "color": "#E67E22", "metadata": {"lineno": 239, "col_offset": 16, "args_count": 1}}, {"id": "call_sleep", "type": "CALL", "status": "COMPLETE", "content_preview": "sleep", "color": "#E67E22", "metadata": {"lineno": 87, "col_offset": 16, "args_count": 1}}, {"id": "call_group", "type": "CALL", "status": "COMPLETE", "content_preview": "group", "color": "#E67E22", "metadata": {"lineno": 161, "col_offset": 34, "args_count": 1}}, {"id": "call_execute_tool", "type": "CALL", "status": "COMPLETE", "content_preview": "execute_tool", "color": "#E67E22", "metadata": {"lineno": 240, "col_offset": 31, "args_count": 2}}, {"id": "call_getmtime", "type": "CALL", "status": "COMPLETE", "content_preview": "getmtime", "color": "#E67E22", "metadata": {"lineno": 84, "col_offset": 19, "args_count": 1}}, {"id": "call_str", "type": "CALL", "status": "COMPLETE", "content_preview": "str", "color": "#E67E22", "metadata": {"lineno": 247, "col_offset": 65, "args_count": 1}}], "links": [{"source": "code_8986981870346077726", "target": "phantom_import_json", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_logging", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_yaml", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_os", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_time", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_abc", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_typing", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_cryptography.hazmat.primitives.asymmetric", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_cryptography.hazmat.primitives", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_infrastructure.llm_gateway", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_core.ontology", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_infrastructure.mcp_hub", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "phantom_import_re", "type": "DEPENDS_ON", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "class_BaseAgent", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "function___init__", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "function__save_keys", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "function_acquire_lock", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "function_release_lock", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "function_sign_content", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "function__hydrate_prompt", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "function__parse_json_response", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "function_get_tools_schema", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "function_check_tool_permission", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "function_execute_tool_calls", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "function_process", "type": "CONTAINS", "color": "#2ECC71", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_LLMGateway", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_getLogger", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_generate", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_public_key", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call__save_keys", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_get", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_makedirs", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_public_bytes", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_time", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_exists", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_encode", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_hex", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_format", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_strip", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_search", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_print", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_warning", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_join", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_open", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_safe_load", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_read", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_write", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_remove", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_ValueError", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_loads", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_get_tools_for_role", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_isinstance", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_dumps", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_sign", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_check_tool_permission", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_append", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_info", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_sleep", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_group", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_execute_tool", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_getmtime", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}, {"source": "code_8986981870346077726", "target": "call_str", "type": "REFERENCES", "color": "#E74C3C", "signed_by": null, "created_at": null}]};

        const width = window.innerWidth;
        const height = window.innerHeight;

        const svg = d3.select("#graph")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        const simulation = d3.forceSimulation(data.nodes)
            .force("link", d3.forceLink(data.links).id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2));

        const link = svg.append("g")
            .selectAll("line")
            .data(data.links)
            .join("line")
            .attr("class", "link")
            .attr("stroke", d => d.color)
            .attr("stroke-width", 2);

        const node = svg.append("g")
            .selectAll("g")
            .data(data.nodes)
            .join("g")
            .attr("class", "node")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        node.append("circle")
            .attr("r", 20)
            .attr("fill", d => d.color);

        node.append("text")
            .attr("dy", 4)
            .attr("text-anchor", "middle")
            .text(d => d.type);

        node.append("title")
            .text(d => d.id + "\n" + d.content_preview);

        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            node.attr("transform", d => `translate(${d.x},${d.y})`);
        });

        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
    </script>
</body>
</html>