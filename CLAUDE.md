# GAADP Constructor - Governance Rules

**CRITICAL: Read these before modifying `core/`, `agents/`, or `config/`:**
- **`docs/ARCHITECTURE_GUARDRAILS.md`** - Practical coding patterns (graph-first outputs, no hardcoding)
- **`docs/GRAPH_INVARIANTS.md`** - Mathematical invariants (Euler paths, DAG validation, soundness proofs)

This document and the above capture lessons learned from recurring failures.

---

## The Single Source of Truth

**`core/ontology.py` is the constitution of this system.**

Everything in this codebase MUST derive from the ontology. This includes:
- Node types (`NodeType` enum)
- Node statuses (`NodeStatus` enum)
- Edge types (`EdgeType` enum)
- State transitions (`TRANSITION_MATRIX`)
- Agent dispatch rules (`AGENT_DISPATCH`)

## The Graph-Native Principle

**NEVER hardcode values that are defined in the ontology.**

### Anti-patterns (DO NOT DO THIS):
```python
# BAD: Hardcoded status check
if status == "VERIFIED":
    ...

# BAD: Hardcoded transition assumption
target_status = NodeStatus.PROCESSING  # What if this node type goes to TESTING?

# BAD: Incomplete status handling
STATUS_SHAPES = {
    NodeStatus.PENDING.value: "ellipse",
    NodeStatus.VERIFIED.value: "circle",
    # Missing TESTING, TESTED, PROCESSING, BLOCKED, FAILED!
}

# BAD: Non-existent enum value
NodeStatus.COMPLETE.value  # COMPLETE doesn't exist!
```

### Correct patterns:
```python
# GOOD: Use enum values
if status == NodeStatus.VERIFIED.value:
    ...

# GOOD: Derive from TRANSITION_MATRIX
from core.ontology import TRANSITION_MATRIX
valid_transitions = TRANSITION_MATRIX.get((current_status, node_type), [])

# GOOD: Generate from enum (covers all values)
STATUS_SHAPES = {status.value: get_shape(status) for status in NodeStatus}

# GOOD: Check ontology before using
assert hasattr(NodeStatus, 'COMPLETE'), "COMPLETE is not a valid NodeStatus"
```

## Canonical File Structure

Only these directories contain production code:

```
gaadp-constructor/
├── core/           # Ontology, protocols, entities
├── agents/         # Agent implementations
├── infrastructure/ # Runtime, graph DB, LLM gateway
├── orchestration/  # Wavefront, consensus, alerts
├── requirements/   # Socratic engine
├── config/         # YAML manifests
└── gaadp_main.py   # Entry point
```

## File Lifecycle Rules

### Creating new files
1. **Experiments go in `workspace/`** - Never in root or canonical directories
2. **Generated outputs go in `workspace/`** - Code generated by GAADP pipeline
3. **Test scripts are temporary** - Delete after debugging or move to `workspace/`

### Integrating experimental code
If experimental code proves valuable:
1. Review against ontology compliance
2. Move to appropriate canonical directory
3. Add imports to `__init__.py`
4. Delete original from workspace

### Cleanup protocol
Files in these locations are ephemeral:
- `workspace/` - GAADP-generated outputs
- `.gaadp/` - Runtime state

## The Elephant Graveyard (`.to_delete/`)

The `.to_delete/` directory is **NOT trash** - it's an archive of ideas we intended to
implement but didn't succeed in integrating into the canonical codebase.

**What's in there:**
- Benchmark scripts that showed promising approaches
- Test harnesses that explored edge cases
- Experimental features that may be needed later
- Visualizers, utilities, and tools that worked but weren't production-ready
- Scripts for specific tasks that could inform future similar work

**How to use it:**
When implementing new functionality, **check the graveyard first**. Similar work may
already exist that can inform or accelerate development.

**Rule:** Do not delete `.to_delete/` contents without review. When a feature is needed
that resembles archived code, use the archive as a starting point rather than building
from scratch

## Status/Type Coverage Rules

When writing code that handles node statuses or types:

1. **Always iterate over the enum** to ensure complete coverage
2. **Use `.get()` with explicit default** for dict lookups
3. **Log warnings for unhandled values** during development

Example:
```python
def get_status_color(status: str) -> str:
    from core.ontology import NodeStatus

    colors = {
        NodeStatus.PENDING.value: "gray",
        NodeStatus.PROCESSING.value: "orange",
        NodeStatus.TESTING.value: "purple",
        NodeStatus.TESTED.value: "blue",
        NodeStatus.BLOCKED.value: "red",
        NodeStatus.VERIFIED.value: "green",
        NodeStatus.FAILED.value: "darkred",
    }

    # Validate complete coverage at import time
    assert set(colors.keys()) == {s.value for s in NodeStatus}, \
        "STATUS_COLORS missing values!"

    return colors.get(status, "gray")
```

## Adding New Statuses or Types

When adding to ontology:
1. Update `core/ontology.py` (the ONLY place)
2. grep for existing uses: `grep -r "NodeStatus\." --include="*.py"`
3. Update all hardcoded references found
4. Verify with: `python -c "from core.ontology import NodeStatus; print([s.value for s in NodeStatus])"`

## Known Violations to Fix

All known violations have been fixed as of the last governance audit.

| File | Status |
|------|--------|
| `orchestration/wavefront.py:17` | **FIXED** - Uses VERIFIED/TESTED instead of non-existent COMPLETE |
| `infrastructure/checkpoint.py:107-113` | **FIXED** - Uses NodeStatus enum values |
| `infrastructure/visualizer.py:27-35` | **FIXED** - STATUS_SHAPES covers all 7 statuses |
| `infrastructure/visualizer.py:182-195` | **FIXED** - Mermaid export handles all statuses |

## Protocol Design (LLM Output Schemas)

**NEVER use `List[ComplexObject]` in agent output protocols.**

LLMs incorrectly serialize nested object arrays - they return JSON strings instead of
arrays, omit required fields, or double-serialize.

### Anti-pattern (causes failures):
```python
# BAD: Nested arrays of complex objects
class ResearcherOutput(BaseModel):
    examples: List[Example]  # LLM will mis-serialize this
    tests: List[UnitTest]    # And this
```

### Correct pattern:
```python
# GOOD: Flat structures with graph relationships
class AgentOutput(BaseModel):
    new_nodes: List[NodeSpec]  # Flat: {type, content, metadata}
    new_edges: List[EdgeSpec]  # Relationships expressed as graph edges
```

**See `docs/ARCHITECTURE_GUARDRAILS.md` for the full policy and refactoring plan.**

## Pre-commit Checklist

Before committing changes:
- [ ] No new files in root directory (except CLAUDE.md, README.md, requirements.txt)
- [ ] No hardcoded status/type strings (use enums)
- [ ] All NodeStatus/NodeType values handled
- [ ] Experimental code in workspace/, not canonical dirs
- [ ] No new `List[ComplexObject]` in protocols (use graph nodes/edges)
